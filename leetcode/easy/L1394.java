class L1394 {
    /**
     * 2025/7/6 时间93.62%  
     * 出现次数和数字本身相等，首先是想到hash，即检查key与value关系
     * 不过我们看到arr.length,arr[i]都是1到500结合map可以由数组得到，即特殊的数组，所以我们可以考虑使用数组。
     * 即计数排序的思想，不过考虑到第n个数的索引是n-1，我们多弄出来一个空间，索引0所在的那个位置不要。然后就从前到后遍历填入计数数组，然后从后往前找幸运数（因为要的是最大的幸运数）
     */
    public int findLucky(int[] arr) {
        int[] count = new int[501];
        for(int i = 0; i < arr.length; i++) {
            // 若arr[i]为1，则count[1] 自增 1个，是对应的。不存在count[0]，事实上我们使用count[1~500]，count[i]就是i的数目
            count[arr[i]]++;
        }
        for(int i = count.length - 1; i > 0; i--) {
            if (count[i] == i) {
                return count[i];
            }
        }
        return -1;
    }
}
/*
在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。

给你一个整数数组 arr，请你从中找出并返回一个幸运数。

如果数组中存在多个幸运数，只需返回 最大 的那个。
如果数组中不含幸运数，则返回 -1 。
 

示例 1：

输入：arr = [2,2,3,4]
输出：2
解释：数组中唯一的幸运数是 2 ，因为数值 2 的出现频次也是 2 。
*/